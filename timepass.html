<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>local host</title>
</head>
<body>
    <div id="status"></div>
    <button id="startCopyBtn" onclick="copyStepByStep()">Start</button>
    
    <div class="button-container">
        <button onclick="copyText('textToCopy1')" style="display:none;">SLP</button>
        <button onclick="copyText('textToCopy2')" style="display:none;">KNN</button>
        <button onclick="copyText('textToCopy3')" style="display:none;">KMC</button>
        <button onclick="copyText('textToCopy4')" style="display:none;">DT</button>
        <button onclick="copyText('textToCopy5')" style="display:none;">NB</button>
    </div>

    <div class="content-container">
        <div class="content-div">
            <div id="textToCopy1" style="color: white;">
                # SLP

                import numpy as np
                
                def step_function(x):
                    return 1 if x >= 0 else 0
                
                class Perceptron:
                    def __init__(self, input_size, learning_rate=0.1):
                        self.weights = np.zeros(input_size + 1)  # +1 for bias
                        self.learning_rate = learning_rate
                
                    def predict(self, inputs):
                        summation = np.dot(inputs, self.weights[1:]) + self.weights[0]
                        return step_function(summation)
                
                    def train(self, training_inputs, labels, epochs):
                        for _ in range(epochs):
                            for inputs, label in zip(training_inputs, labels):
                                prediction = self.predict(inputs)
                                self.weights[1:] += self.learning_rate * (label - prediction) * inputs
                                self.weights[0] += self.learning_rate * (label - prediction)
                
                training_inputs = []
                training_inputs.append(np.array([0, 0]))
                training_inputs.append(np.array([0, 1]))
                training_inputs.append(np.array([1, 0]))
                training_inputs.append(np.array([1, 1]))
                
                labels = np.array([0, 0, 0, 1])  # AND gate
                
                perceptron = Perceptron(2)
                perceptron.train(training_inputs, labels, 10)
                
                print("Test Results:")
                for inputs in training_inputs:
                    print(f"{inputs} => {perceptron.predict(inputs)}")
                
            </div>
        </div>

        <div class="content-div">
            <div id="textToCopy2" style="color: white;">
                # KNN Classifier

                    import pandas as pd
                    from sklearn.preprocessing import LabelEncoder, StandardScaler
                    from sklearn.neighbors import KNeighborsClassifier

                    # Step 1: Load the dataset
                    data = pd.read_csv("KNN.csv")

                    # Step 2: Preprocess the Data
                    data = data.drop("ID", axis=1)
                    X = data.drop("Label", axis=1)
                    y = data["Label"]

                    # Convert labels to numeric
                    label_encoder = LabelEncoder()
                    y = label_encoder.fit_transform(y)

                    # Normalize features
                    scaler = StandardScaler()
                    X_scaled = scaler.fit_transform(X)

                    # Step 3: Train KNN Model
                    knn = KNeighborsClassifier(n_neighbors=5, metric='manhattan', weights='distance')
                    knn.fit(X_scaled, y)

                    # Step 4: Make Predictions 
                    sample = [[5.1, 3.5, 1.4]]
                    sample_df = pd.DataFrame(sample, columns=X.columns)
                    sample_scaled = scaler.transform(sample_df)
                    prediction = knn.predict(sample_scaled)

                    # Output
                    print("Predicted Label:", label_encoder.inverse_transform(prediction))

            </div>
        </div>

        <div class="content-div">
            <div id="textToCopy3" style="color: white;">
                #KMC

                # Import necessary libraries
                import pandas as pd
                import matplotlib.pyplot as plt
                from sklearn.cluster import KMeans

                # Load CSV data
                print("Loading data for K-Means Clustering...")
                data = pd.read_csv('KMC.csv')  # Replace with your actual CSV file

                # Preprocess Data (select features)
                X = data[['Annual_Income', 'Spending_Score']]

                # Apply K-Means Clustering
                kmeans = KMeans(n_clusters=3, random_state=42)
                kmeans.fit(X)
                data['Cluster'] = kmeans.labels_

                # Determine Optimal K using the Elbow Method
                inertia = []
                for k in range(1, 11):
                    km = KMeans(n_clusters=k, random_state=42)
                    km.fit(X)
                    inertia.append(km.inertia_)

                plt.figure(figsize=(8, 4))
                plt.plot(range(1, 11), inertia, marker='o')
                plt.xlabel('Number of clusters')
                plt.ylabel('Inertia')
                plt.title('Elbow Method for Optimal K')
                plt.grid(True)
                plt.show()

                # Visualize the Clusters
                plt.figure(figsize=(8, 6))
                plt.scatter(X['Annual_Income'], X['Spending_Score'], c=data['Cluster'], cmap='viridis')
                plt.xlabel('Annual Income')
                plt.ylabel('Spending Score')
                plt.title('Customer Segmentation using K-Means')
                plt.colorbar(label='Cluster')
                plt.grid(True)
                plt.show()
            </div>
        </div>

        <div class="content-div">
            <div id="textToCopy4" style="color: white;">
                #DT

                import pandas as pd 
                from sklearn.preprocessing import LabelEncoder 
                from sklearn.metrics import accuracy_score, classification_report 
                from sklearn import tree 
                from sklearn.model_selection import train_test_split 


                # Load the dataset 
                df = pd.read_csv('DT.csv') 
                # Display the first 5 rows 
                print(df.head()) 

                inputs = df.drop('salary_more_then_100k', axis='columns') 
                target = df['salary_more_then_100k'] 


                le_company = LabelEncoder() 
                le_job = LabelEncoder() 
                le_degree = LabelEncoder() 

                inputs['company'] = le_company.fit_transform(inputs ['company']) 
                inputs['job'] = le_job.fit_transform(inputs ['job']) 
                inputs['degree'] = le_degree.fit_transform(inputs ['degree']) 


                # Split data into train and test sets 
                X_train, X_test, y_train, y_test = train_test_split(inputs, target, test_size=0.2, random_state=None) 
                #Initialize and train model 
                model = tree. DecisionTreeClassifier() 
                model.fit(X_train, y_train)


                # Predict on test data 
                predictions = model.predict(X_test) 
                # Evaluate model 
                print("Accuracy:", accuracy_score(y_test, predictions)*100,"%")


                input_example = pd. DataFrame ([[2, 1, 0]], columns=X_test.columns) 
                # Predict using a DataFrame with valid feature names 
                prediction = model.predict(input_example) 
                print("Prediction:", prediction)
            </div>
        </div>

        <div class="content-div">
            <div id="textToCopy5" style="color: white;">
                #NB

                import pandas as pd
                from sklearn.model_selection import train_test_split
                from sklearn.naive_bayes import GaussianNB
                from sklearn.preprocessing import LabelEncoder
                from sklearn.metrics import accuracy_score

                # Step 1: Load the Dataset
                data = pd.read_csv("iris.csv")

                # Step 2: Preprocess the Data
                X = data.drop("species", axis=1)
                y = data["species"]

                # Convert categorical labels to numbers
                label_encoder = LabelEncoder()
                y = label_encoder.fit_transform(y)

                # Step 3: Train-Test Split
                X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

                # Step 4: Train the Naive Bayes Classifier
                model = GaussianNB()
                model.fit(X_train, y_train)

                # Step 5: Predict and Evaluate
                y_pred = model.predict(X_test)
                accuracy = accuracy_score(y_test, y_pred)
                print("Accuracy:", accuracy)

            </div>
        </div>
    </div>

    <script>
        function updateStatus(message) {
            document.getElementById('status').textContent = message;
        }

        async function copyToClipboard(text) {
            try {
                // Try modern clipboard API first
                if (navigator.clipboard && window.isSecureContext) {
                    await navigator.clipboard.writeText(text);
                    return true;
                }
                
                // Fallback 1: execCommand
                const textarea = document.createElement('textarea');
                textarea.value = text;
                document.body.appendChild(textarea);
                textarea.select();
                const success = document.execCommand('copy');
                document.body.removeChild(textarea);
                if (success) return true;
                
                // Fallback 2: Selection API
                const range = document.createRange();
                const selection = window.getSelection();
                const tempDiv = document.createElement('div');
                tempDiv.textContent = text;
                document.body.appendChild(tempDiv);
                range.selectNodeContents(tempDiv);
                selection.removeAllRanges();
                selection.addRange(range);
                const success2 = document.execCommand('copy');
                selection.removeAllRanges();
                document.body.removeChild(tempDiv);
                return success2;
            } catch (err) {
                console.error('Failed to copy:', err);
                return false;
            }
        }

        function copyText(elementId) {
            const textElement = document.getElementById(elementId);
            copyToClipboard(textElement.textContent);
        }

        // Step by step copy process
        async function copyStepByStep() {
            const steps = [
                { id: 'textToCopy1', name: 'SLP' },
                { id: 'textToCopy2', name: 'KNN' },
                { id: 'textToCopy3', name: 'KMC' },
                { id: 'textToCopy4', name: 'DT' },
                { id: 'textToCopy5', name: 'NB' }
            ];
            document.getElementById('startCopyBtn').disabled = true;
            
            for (let i = 0; i < steps.length; i++) {
                const element = document.getElementById(steps[i].id);
                // updateStatus(` ${steps[i].name}`);
                await copyToClipboard(element.textContent);
                // Wait for a short delay before copying the next block
                await new Promise(resolve => setTimeout(resolve, 350));
            }
            
            // updateStatus('All done!');
            document.getElementById('startCopyBtn').disabled = false;
        }
    </script>
</body>
</html> 